## 1. æ•°æ®åº“

> ä½¿ç”¨ AI æ„å»ºé€šç”¨æ•°æ®è¡¨ï¼Œæç¤ºè¯­ï¼š

```plain
æˆ‘è¦ä½¿ç”¨pg 17æ•°æ®åº“åˆ›å»ºä¸€ä¸ªè¡¨ï¼Œæœ‰å››ä¸ªå­—æ®µï¼Œåˆ†åˆ«æ˜¯
è‡ªå¢idï¼ˆidentityç±»å‹ï¼‰ï¼Œ
åˆ›å»ºæ—¶é—´ï¼ˆå¸¦æ—¶åŒºçš„æ—¶é—´æˆ³ï¼‰ï¼Œ
æ›´æ–°æ—¶é—´ï¼ˆå¸¦æ—¶åŒºçš„æ—¶é—´æˆ³ï¼‰ï¼Œ
dataï¼ˆjsonbç±»å‹ï¼‰ï¼›
ç„¶ååˆ›å»ºä¸€ä¸ªè§¦å‘å™¨ï¼Œè‡ªåŠ¨æ›´æ–°è¡¨ä¸­çš„æ›´æ–°æ—¶é—´ã€‚
è¯·ä½ å¸®æˆ‘å†™ä¸€ä¸‹å¯¹åº”çš„sqlè¯­å¥ã€‚
```

AI ç”Ÿæˆçš„ sql ç¤ºä¾‹å¦‚ä¸‹ï¼š

```sql
-- åˆ›å»ºè¡¨
CREATE TABLE example_table (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    data JSONB
);

-- åˆ›å»ºè§¦å‘å™¨å‡½æ•°
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºè§¦å‘å™¨
CREATE TRIGGER trigger_update_updated_at
    BEFORE UPDATE ON example_table
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

ä½¿ç”¨æ—¶å…ˆæ‰¹é‡ä¿®æ”¹ sql ä¸­çš„è¡¨å example_table, æ¯”å¦‚è¡¨åä¸º template.

## 2. åˆ›å»º hono é¡¹ç›®

> ä½¿ç”¨ node v20 ä»¥ä¸Šç‰ˆæœ¬

### 2.1 å®‰è£…ä¾èµ–

```shell
pnpm init

# ç”Ÿäº§ä¾èµ–
pnpm add hono @hono/node-server pg zod @hono/zod-validator jsonwebtoken winston winston-daily-rotate-file axios qs dayjs lodash

# å¼€å‘ä¾èµ–
pnpm add -D @types/node tsx typescript @types/pg jest @types/jest ts-jest @swc/core @swc/jest dotenv dotenv-cli cross-env @types/jsonwebtoken @types/lodash esbuild rimraf

pnpm create @eslint/config

```

### 2.2 vscode è°ƒè¯•é…ç½®

> æ–°å¢ .vscode/settings.json

```json
{
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.organizeImports": "always",
    "source.fixAll": "always"
  }
}
```

> è¿è¡Œ vscode å‘½ä»¤ç”Ÿæˆé…ç½®æ–‡ä»¶ï¼Œèœå•æ /Run/Add Configuration

```json
{
  // Use IntelliSense to learn about possible attributes.
  // Hover to view descriptions of existing attributes.
  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "launch",
      "name": "Debug Jest Tests",
      "program": "${workspaceFolder}/node_modules/jest/bin/jest.js", // æˆ–è€…ç›´æ¥æŒ‡å‘ jest
      "args": [
        "--runInBand", // å…³é”®ï¼šå¼ºåˆ¶ä¸²è¡Œæ‰§è¡Œæµ‹è¯•ï¼Œä¾¿äºè°ƒè¯•
        "--watchAll=false", // ç¡®ä¿ä¸æ˜¯ç›‘è§†æ¨¡å¼
        "--no-cache" // é¿å…ç¼“å­˜å¯¼è‡´ä»£ç å˜åŒ–æœªç”Ÿæ•ˆ
        // å¯ä»¥æ·»åŠ æ›´å¤š Jest å‚æ•°ï¼Œä¾‹å¦‚ "--testNamePattern=<æµ‹è¯•åç§°æ¨¡å¼>" æ¥è¿‡æ»¤ç‰¹å®šæµ‹è¯•
      ],
      "env": {
        "NODE_OPTIONS": "--experimental-vm-modules" // æ›¿æ¢ cross-env NODE_OPTIONS=--experimental-vm-modules
        // dotenv -e .env.dev çš„åŠŸèƒ½ï¼šJest é€šå¸¸ä¼šè‡ªåŠ¨åŠ è½½ .env æ–‡ä»¶ï¼Œä½†æŒ‡å®šè‡ªå®šä¹‰è·¯å¾„å¯èƒ½éœ€è¦é¢å¤–é…ç½®
        // å¦‚æœ jest æœªè‡ªåŠ¨åŠ è½½ .env.devï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨ jest çš„ `testEnvironmentOptions` æˆ– `setupFiles` é…ç½®
      },
      "envFile": "${workspaceFolder}/.env.dev", // ä½¿ç”¨ VSCode çš„ envFile å±æ€§ç›´æ¥æ³¨å…¥ç¯å¢ƒå˜é‡ï¼Œè¿™é€šå¸¸æ¯”ä½¿ç”¨ dotenv åŒ…æ›´ç®€å•
      "console": "integratedTerminal",
      "internalConsoleOptions": "neverOpen",
      "windows": {
        "program": "${workspaceFolder}/node_modules/jest/bin/jest" // Windows è·¯å¾„å¯èƒ½éœ€è¦çš„è°ƒæ•´
      },
      // å¦‚æœä½ çš„é¡¹ç›®æ˜¯ TypeScriptï¼Œä¸”ä½¿ç”¨äº† ts-jest æˆ–ç±»ä¼¼è½¬æ¢å™¨ï¼Œé€šå¸¸ä¸éœ€è¦åœ¨è°ƒè¯• Jest æ—¶é¢å¤–æŒ‡å®š --import=tsx
      // Jest çš„è½¬æ¢å™¨ä¼šå¤„ç† TypeScript æ–‡ä»¶
      "skipFiles": ["<node_internals>/**"]
    },
    {
      "type": "node",
      "request": "launch",
      "name": "Launch Program",
      "skipFiles": ["<node_internals>/**"],
      "runtimeExecutable": "node",
      "runtimeArgs": ["--env-file=.env.dev", "--import=tsx", "--watch-path=./src"],
      "program": "${workspaceFolder}/src/app.ts",
      "sourceMaps": true
    }
  ]
}
```

### 2.3 ç¯å¢ƒå˜é‡

> .env,.env.dev

```plain
IS_DEV=true
PORT=3000
PGUSER=postgres
PGPASSWORD=0000
PGHOST=localhost
PGPORT=5432
PGDATABASE=my_db
```

### 2.4 æ‰“åŒ…é…ç½®

> esbuild.config.mjs

```javascript
import console from "console";
import esbuild from "esbuild";
import process from "process";

const options = {
  entryPoints: ["src/app.ts"],
  outdir: "dist",
  sourcemap: true,
  bundle: true,
  platform: "node",
  minify: true,
  alias: {
    "@": "src",
  },
};

esbuild.build(options).catch(err => {
  console.error(err);
  process.exit(1);
});
```

### 2.5 eslint é…ç½®

> eslint.config.mjs

```javascript
import js from "@eslint/js";
import globals from "globals";
import tseslint from "typescript-eslint";
import { defineConfig } from "eslint/config";

export default defineConfig([
  { files: ["**/*.{js,mjs,cjs,ts,mts,cts}"], plugins: { js }, extends: ["js/recommended"] },
  { files: ["**/*.{js,mjs,cjs,ts,mts,cts}"], languageOptions: { globals: globals.browser } },
  tseslint.configs.recommended,
  {
    rules: {
      "@typescript-eslint/no-explicit-any": "off",
      "@typescript-eslint/no-empty-object-type": "off",
      "@typescript-eslint/no-unused-vars": "warn",
    },
  },
]);
```

### 2.6 jest å•å…ƒæµ‹è¯•é…ç½®

> jest.config.mjs

```javascript
/**
 * @type {import('jest').Config}
 */
export default {
  clearMocks: true,
  collectCoverage: false,
  coverageDirectory: "coverage",
  coverageProvider: "v8",
  // ts-jestä¸@swc/jestäºŒé€‰ä¸€
  // preset: 'ts-jest',
  transform: {
    "^.+\\.(t|j)s$": "@swc/jest",
  },
  moduleNameMapper: {
    "@/(.*)": "<rootDir>/src/$1",
  },
  testMatch: ["<rootDir>/src/**/*/*.spec.ts"],
};
```

### 2.7 package.json è„šæœ¬è®¾ç½®

```json
{
  "dev": "node --env-file=.env.dev --import=tsx --watch-path=./src src/app.ts",
  "test": "cross-env NODE_OPTIONS=--experimental-vm-modules dotenv -e .env.dev jest",
  "lint": "eslint src --fix",
  "build": "npm run clear && node esbuild.config.mjs",
  "clear": "rimraf dist",
  "start": "node --enable-source-maps --env-file=.env ./dist/app.js",
  "create:type": "tsc --declaration --emitDeclarationOnly"
}
```

### 2.8 tsconfig.json

```json
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "esModuleInterop": true,
    "noImplicitAny": false,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "declaration": true,
    "declarationDir": "router-type",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src"],
  "exclude": ["node_modules"]
}
```

### 2.9 ä¸Šä¸‹æ–‡ç±»å‹é…ç½®

> src/types/hono.d.ts

```typescript
import "hono";
import type { Pool } from "pg";
import type winston from "winston";

declare interface JWTPayload {
  userId: string;
}

declare module "hono" {
  interface ContextVariableMap {
    pool: Pool;
    logger: winston.Logger;
    requestId: string;
    jwtPayload: JWTPayload;
  }
}
```

### 2.10 é€šç”¨ä¸­é—´ä»¶

> æ–°å»ºç›®å½• src/middlewares

#### jwt

```typescript
import { JWTPayload } from "@/types/hono";
import { createMiddleware } from "hono/factory";
import jwt from "jsonwebtoken";
export const createJwtSign = (secret: string) => (payload: JWTPayload) => {
  const token = jwt.sign(payload, secret, { expiresIn: "5m" });
  const refresh_token = jwt.sign(payload, secret, { expiresIn: "7d" });

  return { token, refresh_token };
};

export const createJwtVerify =
  (secret: string) =>
  (token: string): Promise<{ err: jwt.VerifyErrors | null; decoded: any }> => {
    return new Promise(resolve => {
      jwt.verify(token, secret, (err, decoded) => {
        resolve({ err, decoded });
      });
    });
  };

export const createJwtMiddlware = (secret = "jwt") => {
  const { IS_DEV } = process.env;
  const jwtSign = createJwtSign(secret);
  const jwtVerify = createJwtVerify(secret);
  return createMiddleware(async (c, next) => {
    const ignoreRoute = /\/login$|\/register/;
    if (ignoreRoute.test(c.req.url)) {
      await next();
      return;
    }

    const token = c.req.header("Authorization")?.split(" ")[1];
    const data = IS_DEV ? jwtSign({ userId: "123" }) : null;
    if (token) {
      const { err, decoded } = await jwtVerify(token);
      if (err) {
        return c.json({ code: 401, msg: "tokenè¿‡æœŸ", data });
      } else {
        c.set("jwtPayload", decoded);
        await next();
      }
    } else {
      return c.json({ code: 401, msg: "æ²¡æœ‰token", data });
    }
  });
};
```

#### logger

```typescript
import { createMiddleware } from "hono/factory";
import winston from "winston";
import DailyRotateFile from "winston-daily-rotate-file";
import { getConnInfo } from "@hono/node-server/conninfo";

export const createLogger = () => {
  const { IS_DEV } = process.env;

  const transport: DailyRotateFile = new DailyRotateFile({
    auditFile: "logs/log-audit.json",
    filename: "logs/%DATE%.log",
    datePattern: "YYYY-MM-DD",
    zippedArchive: false,
    maxSize: "20m",
    maxFiles: "30d",
  });

  const logger = winston.createLogger({
    level: "info",
    format: winston.format.combine(
      ...[
        winston.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
        winston.format.printf(i => `>${i.level}:${i.timestamp}: ${JSON.stringify(i.message)}\n`),
      ],
    ),
    transports: IS_DEV ? [new winston.transports.Console()] : [transport],
  });

  return logger;
};

export const createLoggerMiddleware = (logger = createLogger()) => {
  return createMiddleware(async (c, next) => {
    try {
      c.set("logger", logger);
      const startTime = Date.now();
      await next();
      const { url, method } = c.req;
      const info = getConnInfo(c).remote;
      const connect = `${info.addressType} ${info.address}:${info.port}`;
      const requestId = c.var.requestId;
      if (c.req.header("Content-Type") === "application/json") {
        const body = await c.req.json();
        logger.info({
          requestId,
          body,
        });
      }
      if (c.res.headers.get("Content-Type") === "application/json") {
        const res = await c.res.clone().json();
        logger.info({
          requestId,
          code: res.code,
        });
      }
      const time = `${Date.now() - startTime}ms`;
      logger.info({
        requestId,
        url,
        method,
        connect,
        param: c.req.param(),
        query: c.req.query(),
        time,
      });
    } catch (error: any) {
      logger.error({ name: "logger middleware error:", error: error.toString() });
    }
  });
};
```

#### pg

```typescript
import { createMiddleware } from "hono/factory";
import { Pool } from "pg";

export const createPgMiddleware = (pool: Pool) => {
  return createMiddleware(async (c, next) => {
    c.set("pool", pool);
    await next();
  });
};
```

### 2.11 å·¥å…·å‡½æ•°

> æ–°å»ºç›®å½• src/utils  
> æ–°å»º validate-fail-handler.ts ç”¨æ¥å¤„ç†æ¥å£å‚æ•°æ ¡éªŒ

```typescript
import { Context } from "hono";
import { HTTPException } from "hono/http-exception";

export const validateFailHandler = (result: any, c: Context<any, string, {}>) => {
  if (!result.success) {
    try {
      const errMessages: Array<{ message: string; path: string[] }> = JSON.parse(result.error.message);
      const msg = errMessages.map(el => `å‚æ•°${el.path.join(",")}é”™è¯¯: ${el.message}`).join("; ");
      return c.json({ code: 400, msg: msg, info: errMessages });
    } catch (error) {
      console.log("ğŸš€ ~ error:", error);
      throw new HTTPException(500, { message: "ç”Ÿæˆå‚æ•°æ ¡éªŒä¿¡æ¯å¤±è´¥" });
    }
  }
};
```

> æ–°å»º error-handler.ts

```typescript
import type { ErrorHandler } from "hono";

export const errorHandler: ErrorHandler = (err, c) => {
  c.var.logger.error({ name: err.name, msg: err.message, stack: err.stack });
  return c.json({ code: 500, msg: err.message });
};
```

### 2.12 ä¸šåŠ¡æ¨¡å—

> æ–°å»ºç›®å½• modules, æ–°å»ºä¸€ä¸ª curd æ¨¡æ¿  
> æ–°å»º template å­ç›®å½•ï¼Œä¸€ä¸ª model.ts, ä¸€ä¸ª index.ts

#### model

```typescript
export type Model = {
  id: number;
  created_at: Date;
  updated_at: Date;
  data: {
    open_id: string;
    name?: string;
  };
};
```

#### index

```typescript
import { validateFailHandler } from "@/utils/validate-fail-handler";
import { zValidator } from "@hono/zod-validator";
import { Hono } from "hono";
import pg from "pg";
import { z } from "zod/v4";
import { Model } from "./model";

export const templateApp = new Hono()
  .post("/", zValidator("json", z.strictObject({ open_id: z.string() }), validateFailHandler), async c => {
    const data = c.req.valid("json");
    const queryConf: pg.QueryConfig = {
      text: `INSERT INTO template (data) VALUES ($1)`,
      values: [data],
    };
    const res = await c.var.pool.query(queryConf);
    return c.json({ code: 200, msg: "success", data: res.rowCount });
  })
  .get("/:id", zValidator("param", z.object({ id: z.string() }), validateFailHandler), async c => {
    const { id } = c.req.valid("param");
    const queryConf: pg.QueryConfig = {
      text: `SELECT * FROM template WHERE id = $1`,
      values: [id],
    };
    const res = await c.var.pool.query<Model>(queryConf);
    return c.json({ code: 200, msg: "success", data: res.rows[0] });
  })
  .put(
    "/:id",
    zValidator("param", z.object({ id: z.string() }), validateFailHandler),
    zValidator("json", z.object({ name: z.string() }), validateFailHandler),
    async c => {
      const { id } = c.req.valid("param");
      const data = c.req.valid("json");
      const queryConf: pg.QueryConfig = {
        text: `UPDATE template SET data = jsonb_set(data, '{name}', $1) WHERE id = $2`,
        values: [JSON.stringify(data.name), id],
      };
      const res = await c.var.pool.query(queryConf);
      return c.json({ code: 200, msg: "success", data: res.rowCount });
    },
  )
  .delete("/:id", zValidator("param", z.object({ id: z.string() }), validateFailHandler), async c => {
    const { id } = c.req.valid("param");
    const queryConf: pg.QueryConfig = {
      text: `DELETE FROM template WHERE id = $1`,
      values: [id],
    };
    const res = await c.var.pool.query(queryConf);
    return c.json({ code: 200, msg: "success", data: res.rowCount });
  })
  .post(
    "/page",
    zValidator("json", z.object({ page: z.number().min(1), pageSize: z.number().min(1) }), validateFailHandler),

    async c => {
      const { page, pageSize } = c.req.valid("json");

      const queryCountRes = await c.var.pool.query(`SELECT COUNT(*) FROM template`);
      const total = Number(queryCountRes.rows[0].count);

      const queryConf: pg.QueryConfig = {
        // åˆ†é¡µæŸ¥è¯¢ æŒ‰idå‡åº
        text: `SELECT * FROM template ORDER BY id DESC LIMIT $1 OFFSET $2`,
        values: [pageSize, (page - 1) * pageSize],
      };
      const res = await c.var.pool.query<Model>(queryConf);

      return c.json({ code: 200, msg: "success", data: { total, list: res.rows } });
    },
  );

export type TemplateApp = typeof templateApp;
```

#### index.spec.ts

```typescript
import { createPgMiddleware } from "@/middlewares/pg";
import { serve } from "@hono/node-server";
import { Hono } from "hono";
import { hc } from "hono/client";
import { Pool } from "pg";
import { TemplateApp, templateApp } from "./index";

describe("test template module", () => {
  const { PORT } = process.env;
  const app = new Hono();

  const pgPool = new Pool();
  app.use(createPgMiddleware(pgPool));
  app.route("/template", templateApp);

  const server = serve({ fetch: app.fetch, port: Number(PORT) });

  const client = hc<TemplateApp>(`http://localhost:${PORT}/template`);

  afterAll(() => {
    server.close();
    pgPool.end();
  });

  it("test add row", async () => {
    const res = await client.index.$post({
      json: {
        open_id: "test_open_id",
      },
    });
    expect(res.ok).toBe(true);
    if (res.ok) {
      const resJSON = await res.json();
      expect(resJSON.code).toBe(200);
      expect(resJSON.data).toBe(1);
    }
  });

  let id = 0;
  it("test find page", async () => {
    const res = await client.page.$post({ json: { page: 1, pageSize: 1 } });
    expect(res.ok).toBe(true);
    if (res.ok) {
      const resJSON = await res.json();
      expect(resJSON.code).toBe(200);
      expect(resJSON.data.total).toBeGreaterThan(0);
      expect(resJSON.data.list.length).toBeLessThanOrEqual(1);
      id = resJSON.data.list[0].id;
    }
  });

  it("test get by id", async () => {
    const res = await client[":id"].$get({ param: { id: id.toString() } });
    expect(res.ok).toBe(true);
    if (res.ok) {
      const resJSON = await res.json();
      expect(resJSON.code).toBe(200);
      expect(resJSON.data.data.open_id).toEqual("test_open_id");
    }
  });

  it("test update by id", async () => {
    const res = await client[":id"].$put({
      param: { id: id.toString() },
      json: {
        name: "test_open_id_updated",
      },
    });
    expect(res.ok).toBe(true);
    if (res.ok) {
      const resJSON = await res.json();
      expect(resJSON.code).toBe(200);
      expect(resJSON.data).toBe(1);
    }
  });

  it("test delete by id", async () => {
    const res = await client[":id"].$delete({ param: { id: id.toString() } });
    expect(res.ok).toBe(true);
    if (res.ok) {
      const resJSON = await res.json();
      expect(resJSON.code).toBe(200);
      expect(resJSON.data).toBe(1);
    }
  });
});
```

### 2.13 é¡¹ç›®å…¥å£ src/app.ts

```typescript
import { serve } from "@hono/node-server";
import { Hono } from "hono";
import { cors } from "hono/cors";
import { requestId } from "hono/request-id";
import { Pool } from "pg";
import { createJwtMiddlware } from "./middlewares/jwt";
import { createLogger, createLoggerMiddleware } from "./middlewares/logger";
import { createPgMiddleware } from "./middlewares/pg";
import { templateApp } from "./modules/template";
import { errorHandler } from "./utils/error-handler";

const boot = () => {
  const { PORT } = process.env;
  const app = new Hono();

  app.use(cors());

  app.use(requestId());

  const logger = createLogger();
  app.use(createLoggerMiddleware(logger));

  app.use(createJwtMiddlware());

  const pgPool = new Pool();
  app.use(createPgMiddleware(pgPool));

  app.route("/template", templateApp);

  app.onError(errorHandler);

  const server = serve(
    {
      fetch: app.fetch,
      port: Number(PORT),
    },
    info => {
      logger.info(`Server is running on http://localhost:${info.port}`);
    },
  );

  process.on("SIGINT", async () => {
    await pgPool.end();
    server.close();
    process.exit(0);
  });

  process.on("SIGTERM", async () => {
    await pgPool.end();
    server.close(err => {
      if (err) {
        logger.error(err);
        process.exit(1);
      }
      process.exit(0);
    });
  });
};

boot();
```
